#include "pch.h"
#include "PointCloud.h"

/// <summary>
/// 
/// </summary>
#define CLASS_NAME                  "PCL - Point Clound"

#define PROP_INPUT_FILE             "Data File"

#define PROP_INPUT_FILE_LOADED      "Data File Loaded (autogenerated)"

#define PROP_CLOUD_POINTS           "Poins coordinates (autogenerated)"
#define PROP_CLOUD_WIDTH            "Cloud width (autogenerated)"
#define PROP_CLOUD_HEIGHT           "Cloud height (autogenerated)"
#define PROP_CLOUD_ISDENSE          "Cloud is dense (autogenerated)"
#define PROP_CLOUD_HDR_SEQ          "Cloud sequence number (autogenerated)"
#define PROP_CLOUD_HDR_STAMP        "Cloud timestamp (autogenerated)"
#define PROP_CLOUD_HDR_FRAME        "Cloud frame_id (autogenerated)"

#define PROP_ENABLE_MLS             "Smooth by Moving Least Squares (F)"

#define PARAM_NEIGHBORS             "Param: Noraml-Neighbors (20)"

#define PROP_POINT_CLOUD            "Point Cloud"

/// <summary>
/// 
/// </summary>
static PointCloudGeometry s_Geometry;

/// <summary>
/// 
/// </summary>
bool PointCloud::CreateClass(OwlModel model)
{
    REQUIRED(!GetClassByName(model, CLASS_NAME), "class already exists\n");

    OwlClass clsPointCloud = ::CreateClass(model, CLASS_NAME);
    REQUIRED(clsPointCloud, "Failed to create class\n");

    AddClassProperty(clsPointCloud, PROP_INPUT_FILE, DATATYPEPROPERTY_TYPE_STRING, 1);
    AddClassProperty(clsPointCloud, PROP_ENABLE_MLS, DATATYPEPROPERTY_TYPE_BOOLEAN, 1);
    AddClassProperty(clsPointCloud, PARAM_NEIGHBORS, DATATYPEPROPERTY_TYPE_INTEGER);

    AddClassProperty(clsPointCloud, PROP_INPUT_FILE_LOADED, DATATYPEPROPERTY_TYPE_STRING); 
    AddClassProperty(clsPointCloud, PROP_CLOUD_WIDTH, DATATYPEPROPERTY_TYPE_INTEGER);
    AddClassProperty(clsPointCloud, PROP_CLOUD_HEIGHT, DATATYPEPROPERTY_TYPE_INTEGER);
    AddClassProperty(clsPointCloud, PROP_CLOUD_POINTS, DATATYPEPROPERTY_TYPE_DOUBLE, 0, NULL, -1);
    AddClassProperty(clsPointCloud, PROP_CLOUD_ISDENSE, DATATYPEPROPERTY_TYPE_BOOLEAN);
    AddClassProperty(clsPointCloud, PROP_CLOUD_HDR_SEQ, DATATYPEPROPERTY_TYPE_INTEGER);
    AddClassProperty(clsPointCloud, PROP_CLOUD_HDR_STAMP, DATATYPEPROPERTY_TYPE_INTEGER);
    AddClassProperty(clsPointCloud, PROP_CLOUD_HDR_FRAME, DATATYPEPROPERTY_TYPE_STRING);

    engine_SetClassGeometryShellBasedSolid(clsPointCloud, &s_Geometry);

    return true;
}

/// <summary>
/// 
/// </summary>
int_t PointCloud::GetPointsCoords(OwlInstance inst, double** coords)
{
    auto filePath = GetFilePathIfNeedToRead(inst);
    if (!filePath.empty()) {
        ReadCloudFileAndSaveOnInstance(inst, filePath);
    }

    return GetDataProperyValue(inst, PROP_CLOUD_POINTS, (void**)coords);
}

/// <summary>
/// 
/// </summary>
pcl::PointCloud<pcl::PointNormal>::Ptr PointCloud::GetPointCloud(OwlInstance inst)
{
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud;

    auto filePath = GetFilePathIfNeedToRead(inst);
    if (!filePath.empty()) {
        cloud = ReadCloudFileAndSaveOnInstance(inst, filePath);
    }
    else {
        cloud = GetFromInstance(inst);
    }

    return GetCloudWithNormals(inst, cloud);
}


/// <summary>
/// 
/// </summary>
pcl::PointCloud<pcl::PointXYZ>::Ptr PointCloud::ReadCloudFileAndSaveOnInstance(OwlInstance inst, const std::string& filePath)
{
    std::string ext;
    if (filePath.length() > 3)
        ext = filePath.substr(filePath.length() - 4);

    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);

    if (0 == _stricmp(ext.c_str(), ".pcd")){
        pcl::io::loadPCDFile<pcl::PointXYZ>(filePath, *cloud);
    }
    else if (0 == _stricmp(ext.c_str(), ".ply")) {
        pcl::PolygonMesh mesh;
        if (pcl::io::loadPLYFile(filePath, mesh)!=-1) {
            pcl::fromPCLPointCloud2(mesh.cloud, *cloud);
        }
    }

    if (!cloud->size()) {
        printf("Can'r read %s \n", filePath.c_str());
    }

    SaveOnInstance(inst, cloud);

    return cloud;
}

/// <summary>
/// 
/// </summary>
pcl::PointCloud<pcl::PointNormal>::Ptr PointCloud::GetCloudWithNormals(OwlInstance inst, pcl::PointCloud<pcl::PointXYZ>::Ptr cloud)
{
    pcl::PointCloud<pcl::PointNormal>::Ptr cloudWithNormal = NULL;
    if (cloud && cloud->size() > 0) {
        bool enableMLS = GetDataProperyValue(inst, PROP_ENABLE_MLS, false);
        if (enableMLS) {
            cloudWithNormal = SmoothMLS(inst, cloud);
        }
        else {
            cloudWithNormal = EstimateNormals(inst, cloud);
        }
    }
    return cloudWithNormal;
}

/// <summary>
/// 
/// </summary>
void PointCloud::Dump(pcl::PointCloud<pcl::PointNormal>::Ptr cloud)
{
    printf("------------------------------------\n");
    printf("Dump cloud\n");
    if (cloud) {
        printf ("SEQ: %d, STAMP: %d, FRAME_ID: %s, is_dense: %d\n", (int)cloud->header.seq, (int)cloud->header.stamp, cloud->header.frame_id.c_str(), (int)cloud->is_dense);
        printf("Width %d, Height: %d, Size: %d\n", (int)cloud->width, (int)cloud->height, (int)cloud->size());

        for (int_t h = 0; h < cloud->height; h++) {
            if (h < 7) {
                for (int_t w = 0; w < cloud->width; w++) {
                    if (w < 7) {
                        int_t i = h * cloud->width + w;
                        auto& pt = cloud->at(i);
                        printf("    [%d,%d] : P(%g,%g,%g) N(%g,%g,%g)\n", (int)h, (int)w, pt.x, pt.y, pt.z, pt.normal_x, pt.normal_y, pt.normal_z);
                    }
                    else {
                        printf("   .....\n");
                        break;
                    }
                }
            }
            else {
                printf(".........\n");
                break;
            }
        }

    }
    printf("------------------------------------\n");
}

/// <summary>
/// 
/// </summary>
void PointCloud::SaveOnInstance(OwlInstance inst, pcl::PointCloud <pcl::PointXYZ>::Ptr cloud)
{
    std::vector<double> coords;
    int_t height = 0;
    int_t width = 0;
    bool is_dense = false;
    int_t hdrSeq = 0;
    int_t hdrStm = 0;
    const char* hdrFrm = "";

    if (cloud) {
        height = cloud->height;
        width = cloud->width;
        assert(height * width == cloud->size());
        is_dense = cloud->is_dense;
        hdrSeq = cloud->header.seq;
        hdrStm = cloud->header.stamp;
        hdrFrm = cloud->header.frame_id.c_str();

        coords.resize(cloud->size() * 3);

        for (int_t h = 0; h < height; h++) {
            for (int_t w = 0; w < width; w++) {
                int_t i = h * width + w;

                auto& pt = cloud->at(i);

                coords[i * 3 + 0] = pt.x;
                coords[i * 3 + 1] = pt.y;
                coords[i * 3 + 2] = pt.z;
            }
        }
    }

    auto model = GetModel(inst);
    auto propPoints = GetPropertyByName(model, PROP_CLOUD_POINTS);
    auto propWidth = GetPropertyByName (model, PROP_CLOUD_WIDTH);
    auto propHeight = GetPropertyByName (model, PROP_CLOUD_HEIGHT);
    auto propIsDens = GetPropertyByName (model, PROP_CLOUD_ISDENSE);
    auto propHdrSeq = GetPropertyByName (model, PROP_CLOUD_HDR_SEQ);
    auto propHdrStm = GetPropertyByName (model, PROP_CLOUD_HDR_STAMP);
    auto propHdrFrm = GetPropertyByName (model, PROP_CLOUD_HDR_FRAME);

    SetDataTypeProperty(inst, propPoints, coords.data(), coords.size());
    SetDataTypeProperty(inst, propWidth, &width, 1);
    SetDataTypeProperty(inst, propHeight, &height, 1);
    SetDataTypeProperty(inst, propIsDens, &is_dense, 1);
    SetDataTypeProperty(inst, propHdrSeq, &hdrSeq, 1);
    SetDataTypeProperty(inst, propHdrStm, &hdrStm, 1);
    SetDataTypeProperty(inst, propHdrFrm, &hdrFrm, 1);
}

/// <summary>
/// 
/// </summary>
pcl::PointCloud<pcl::PointXYZ>::Ptr PointCloud::GetFromInstance(OwlInstance inst)
{
    auto width = GetDataProperyValue<int_t>(inst, PROP_CLOUD_WIDTH, 0);
    auto height = GetDataProperyValue<int_t>(inst, PROP_CLOUD_HEIGHT, 0);
    if (width * height <= 0) {
        return NULL;
    }

    double* coords = NULL;
    int_t ncoords = GetDataProperyValue(inst, PROP_CLOUD_POINTS, (void**)&coords);
    if (ncoords != 3 * width * height) {
        printf("ncoords != 3 * width * height\n");
        return NULL;
    }

    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);

    cloud->is_dense = GetDataProperyValue(inst, PROP_CLOUD_ISDENSE, false);
    cloud->header.seq = GetDataProperyValue<int_t>(inst, PROP_CLOUD_HDR_SEQ, 0);
    cloud->header.stamp = GetDataProperyValue<int_t>(inst, PROP_CLOUD_HDR_STAMP, 0);
    cloud->header.frame_id = GetDataProperyValue(inst, PROP_CLOUD_HDR_FRAME, "");

    // load cloud
    cloud->resize(width * height);

    for (int_t h = 0; h < height; h++) {
        for (int_t w = 0; w < width; w++) {
            int_t i = h * width + w;

            auto& pt = cloud->at(i);

            pt.x = coords[i * 3 + 0];
            pt.y = coords[i * 3 + 1];
            pt.z = coords[i * 3 + 2];
        }
    }

    return cloud;
}


/// <summary>
/// 
/// </summary>
std::string PointCloud::GetFilePathIfNeedToRead(OwlInstance inst)
{
    OwlModel model = GetModel(inst);
    if (!model)
        return "";

    //
    // get file path
    //
    const char* filePath = GetDataProperyValue<const char*>(inst, PROP_INPUT_FILE, "");
    if (!filePath) filePath = "";

    if (*filePath == '"')
        filePath++;
    
    std::string dataFilePath (filePath);
  
    if (dataFilePath.back() == '"') {
        dataFilePath.pop_back();
    }

    //
    // loading mark
    //
    struct stat fstat;
    if (0!=stat(dataFilePath.c_str(), &fstat))
    {
        fstat.st_mtime = 0;
    }

    char timestamp[80];
    sprintf_s(timestamp, "%lld,", fstat.st_mtime);

    std::string loadingMark(timestamp);
    loadingMark.append(dataFilePath);

    RdfProperty propMark = 0;
    const char* existingMark = GetDataProperyValue(inst, PROP_INPUT_FILE_LOADED, "", &propMark);

    if (0 == strcmp(existingMark, loadingMark.c_str())) {
        return "";
    }
    
    existingMark = loadingMark.c_str();
    SetDataTypeProperty(inst, propMark, &existingMark, 1);

    return dataFilePath;
}

/// <summary>
/// 
/// </summary>
pcl::PointCloud<pcl::PointNormal>::Ptr PointCloud::SmoothMLS(OwlInstance inst, pcl::PointCloud<pcl::PointXYZ>::Ptr cloud)
{
    pcl::PointCloud<pcl::PointNormal>::Ptr cloud_smoothed(new pcl::PointCloud<pcl::PointNormal>);

    pcl::MovingLeastSquares<pcl::PointXYZ, pcl::PointNormal> mls;
    mls.setInputCloud(cloud);
    mls.setSearchRadius(0.05); 
    mls.setPolynomialOrder(2);
    mls.setComputeNormals(true);
    mls.setUpsamplingMethod(pcl::MovingLeastSquares<pcl::PointXYZ, pcl::PointNormal>::NONE);

    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);
    mls.setSearchMethod(tree);

    mls.process(*cloud_smoothed);

    return cloud_smoothed;
}

/// <summary>
/// 
/// </summary>
pcl::PointCloud<pcl::PointNormal>::Ptr PointCloud::EstimateNormals(OwlInstance inst, pcl::PointCloud<pcl::PointXYZ>::Ptr cloud)
{
    // Normals
    pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> n;
    pcl::PointCloud<pcl::Normal>::Ptr normals(new pcl::PointCloud<pcl::Normal>);
    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);
    tree->setInputCloud(cloud);
    n.setInputCloud(cloud);
    n.setSearchMethod(tree);
    n.setKSearch(GetDataProperyValue<int_t>(inst, PARAM_NEIGHBORS, 20)); //
    n.compute(*normals);

    // join points with normals
    pcl::PointCloud<pcl::PointNormal>::Ptr cloud_with_normals(new pcl::PointCloud<pcl::PointNormal>);

    pcl::concatenateFields(*cloud, *normals, *cloud_with_normals);

    return cloud_with_normals;
}

/// <summary>
/// 
/// </summary>
bool PointCloud::AddPointCloudProp(OwlClass cls)
{
    auto model = GetModel(cls);
    auto relcls = GetClassByName(model, CLASS_NAME);
    AddClassProperty(cls, PROP_POINT_CLOUD, OBJECTPROPERTY_TYPE, true, relcls);
    return true;
}

/// <summary>
/// 
/// </summary>
OwlInstance PointCloud::GetPointCloudInstance(OwlInstance instHost)
{
    auto model = GetModel(instHost);
    assert(model); if (!model) return NULL;

    auto prop = GetPropertyByName(model, PROP_POINT_CLOUD);
    assert(prop); if (!prop) return NULL;

    return GetObjectProperty(instHost, prop);
}


/// <summary>
/// 
/// </summary>
extern bool AddClassProperty(OwlClass cls, const char* name, RdfPropertyType type, int_t minCard, OwlClass relatedClass, int_t maxCard)
{
    auto model = GetModel(cls);

    RdfProperty prop = GetPropertyByName(model, name);
    if (prop) {
        REQUIRED(GetPropertyType(prop) == type, "Property type mismatch");
    }
    else {
        prop = CreateProperty(model, type, name);
        REQUIRED(prop, "Faile to create of property");
    }

    SetClassPropertyCardinalityRestriction(cls, prop, minCard, maxCard);

    if (type == OBJECTPROPERTY_TYPE && relatedClass) {
        SetPropertyRangeRestriction(prop, relatedClass, TRUE);
    }

    return true;
}

/// <summary>
/// 
/// </summary>
bool PointCloudGeometry::GetBoundingBox(OwlInstance inst, VECTOR3* startVector, VECTOR3* endVector, MATRIX* transformationMatrix)
{
    double* coords = NULL;
    if (auto Ncoords = PointCloud::GetPointsCoords(inst, &coords)) {

        startVector->x = startVector->y = startVector->z = DBL_MAX;
        endVector->x = endVector->y = endVector->z = -DBL_MAX;

        for (int_t i = 0; i < Ncoords / 3; i++) {
            startVector->x = std::min(startVector->x, coords[3 * i + 0]);
            startVector->y = std::min(startVector->y, coords[3 * i + 1]);
            startVector->z = std::min(startVector->z, coords[3 * i + 2]);
            endVector->x = std::max(endVector->x, coords[3 * i + 0]);
            endVector->y = std::max(endVector->y, coords[3 * i + 1]);
            endVector->z = std::max(endVector->z, coords[3 * i + 2]);
        }

        MatrixIdentity(transformationMatrix);

        return true;
    }
    else {
        return false;
    }

}

/// <summary>
/// 
/// </summary>
void PointCloudGeometry::CreateShell(OwlInstance inst, SHELL* shell, IMemory* memory)
{
    double* coords = NULL;
    int_t n_coords = PointCloud::GetPointsCoords(inst, &coords);
    
    if (n_coords < 3)
        return;
    
    shell->noVertices = n_coords / 3;
    shell->nonTransformedVertices = (VECTOR3*)memory->Allocate(shell->noVertices * sizeof(VECTOR3));

    shell->conceptualFaces = memory->new__CONCEPTUAL_FACE();
    VERTEX__LIST** ppPoints = &shell->conceptualFaces->points;

    for (int_t npt = 0; npt < shell->noVertices; npt++) {
        shell->nonTransformedVertices[npt].x = coords[npt * 3 + 0];
        shell->nonTransformedVertices[npt].y = coords[npt * 3 + 1];
        shell->nonTransformedVertices[npt].z = coords[npt * 3 + 2];

        (*ppPoints) = (VERTEX__LIST*)memory->Allocate(sizeof(VERTEX__LIST));
        if (npt < shell->noVertices - 1)
            (*ppPoints)->point = npt;
        else
            (*ppPoints)->point = -(npt + 1);
        ppPoints = &(*ppPoints)->next;

    }
}
